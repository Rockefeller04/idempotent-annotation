这是一个组件，使用 **SpringAOP+注解** 的形式解决幂等问题，在设计上使用策略模式、模板方法模式、满足开闭原则。可以直接使用 **@idemponent** 注解来实现幂等。

幂等场景 Scene ：幂等出现的场景可能有多种，在注解中通过 `scene` 参数来指定幂等场景是REST API场景还是MQ场景。

验证类型 Type ：可以指定幂等的验证类型，支持Token验证、方法参数验证以及SpEL表达式验证。


这是一个还可以持续完善的组件：

    - MQ场景下已经在RocketMQ上调试通过，欢迎各位提交RabbitMQ、Kafka等测试。
    
    - 使用去重表完成MQ场景下的幂等，当前仅支持Redis来实现，这是出于认为数据库在性能上不占优，但若有新的场景可以用到数据库来做去重表，欢迎补充。

1、什么是幂等问题?

    - 接口幂等：接口防重复提交
        例如：提交订单时由于你快速点击多次，或者网络波动提交服务端多次请求，这会导致业务出现错误，如果做了幂等处理，则只有第一次请求是生效的。
    - 消息队列幂等：如何保障消息队列客户端对相同的消息仅消费一次。
        默认我们常见的消息队列都是具备持久性、高可靠的，消息消费失败了会重试，RabbitMQ、RocketMQ甚至会在失败多次后将消息加入 **死信队列** 。
        正是由于这种高可靠，导致服务器产生了客户端是否消费成功的疑问时，客户端就需要再次消费，导致消息被重复消费。

2、如果不做防重复提交或者幂等，可能会导致哪些问题：

    - 数据一致性问题
    	重复数据：同一请求多次提交可能导致数据库插入重复记录（如重复订单、支付记录等）。
    	状态不一致：例如支付接口被重复调用，可能导致用户被多次扣款，而订单状态仅更新一次。
    
    - 业务逻辑错误
    	超额操作：如优惠券被重复领取、库存超卖（库存扣减多次但实际只卖出一件商品）。
    	循环依赖：下游系统依赖上游的幂等性，若上游未处理，可能触发下游的重复逻辑（如重复发送短信/邮件）。
    
    - 资源浪费与性能问题
    	无效负载：重复请求会消耗服务器CPU、数据库IO、网络带宽等资源。
    	并发竞争：多个相同请求可能引发锁竞争或死锁（如重复抢购同一商品）。


3、如何解决幂等问题
    
    - 防重复提交
        分布式锁：当用户提交请求时，服务器端可以生成一个唯一的标识，例如UUID。在处理用户请求之前，服务器尝试获取一个分布式锁，若成功则正常执行业务流程。结束了释放锁。
        Token令牌：
            客户端在第一次调用业务请求之前会发送一个获取 Token 的请求。服务端会生成一个全局唯一的 ID 作为 Token，并将其保存在 Redis 中，同时将该 ID 返回给客户端。
            客户端进行第二次业务请求时，必须携带这个 Token。服务端验证成功，则执行业务逻辑并从 Redis 中删除该 Token。否则，即 Redis 没有该 Token，为重复操作，则直接返回指定的结果给客户端。
    - 防重复消费
        去重表：在使用 Redis 或者 MySQL 作为存储时，为实现幂等性而用于记录已经处理过的请求或操作以防重复执行。这里是用 Redis 作为去重组件实现，其实就是存储一个String类型的Key而已。
        当客户端发送请求时，服务端会先查询 Redis 去重表来检查该请求是否已经被处理过。如果不存在，就将新请求的唯一标识（如请求ID或标识）添加到 Redis 去重表中。
        如果消息在消费中，抛出异常，消息会触发延迟消费，在消息队列消费失败的场景下即发送到重试队列 RETRY TOPIC。





4、MQ幂等的处理逻辑：

    - 拼接key前缀和SpEL表达式里面的key，作为最终的key放入Redis
    - 如果key存在，说明Key对应的消息要么已经执行完了，要么是还在执行，所以需要继续判断幂等标识对应的值，并抛出异常给上一层。
    - 根据处理逻辑中抛出来的异常，决定到底要让MQ重试，还是将消息直接吞了即不执行具体的消费流程
        （1）若消息还在处理，但是不确定是否执行成功，那么需要返回错误，方便 MQ 再次通过重试队列投递
        （2）若消息处理成功了，该消息直接返回成功即可
        （3）如果是客户端消费的时候出错了，要把幂等标识删除，这样才会不影响 MQ 再次通过重试队列投递
